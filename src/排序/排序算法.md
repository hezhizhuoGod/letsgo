# 小结

## 1. 排序算法的比较

| 算法 | 稳定性 | 时间复杂度 | 空间复杂度 | 备注 |
| :---: | :---: |:---: | :---: | :---: |
| 选择排序 | × | N<sup>2</sup> | 1 | |
| 冒泡排序 | √ |  N<sup>2</sup> | 1 | |
| 插入排序 | √ |  N \~ N<sup>2</sup> | 1 | 时间复杂度和初始顺序有关 |
| 希尔排序 | ×  |  N 的若干倍乘于递增序列的长度 | 1 | 改进版插入排序 |
| 快速排序 | ×  | NlogN | logN | |
| 三向切分快速排序 | ×  |  N \~ NlogN | logN | 适用于有大量重复主键|
| 归并排序 | √ |  NlogN | N | |
| 堆排序 | ×  |  NlogN | 1 | 无法利用局部性原理|

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 \~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

##选择排序
从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。
```aidl
public void sort(int[] nums)
    {
        //记录要进行多少次
        int N=nums.length;
        for(int i=0;i<N;i++)
        {
            int min=i;//记录循环的角标
            int temp;//临时空间
            for(int j=i;j<N;j++)
            {
                if(nums[j]<nums[min])
                {
                    min=j;
                }
            }
            temp=nums[i];
            nums[i]=nums[min];
            nums[min]=temp;
        }
    }
```
##冒泡排序
算法描述：
1.	i从0开始，i与i+1比较，如果i>i+1，那么就互换 
2.	i不断增加，直到i<n-1（n是数组元素的个数，n-1是数组已经最后一个元素） ，一趟下来，可以让数组元素中最大值排在数组的最后面
3.  优化当一次循环中没有出现交换现象可以视为已经有序
```aidl
//装载临时变量
int temp;

//记录是否发生了置换， 0 表示没有发生置换、 1 表示发生了置换
int isChange;

//外层循环是排序的趟数
for (int i = 0; i < arrays.length - 1; i++) {

  //每比较一趟就重新初始化为0
  isChange = 0;

  //内层循环是当前趟数需要比较的次数
  for (int j = 0; j < arrays.length - i - 1; j++) {

    //前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
    if (arrays[j] > arrays[j + 1]) {
      temp = arrays[j];
      arrays[j] = arrays[j + 1];
      arrays[j + 1] = temp;

      //如果进到这里面了，说明发生置换了
      isChange = 1;

    }
  }
  //如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了
  if (isChange == 0) {
    break;
  }
}


```
##插入排序
每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

```
 for (int i = 1; i < arrays.length; i++) {

  temp = arrays[i];

 //如果前一位(已排序的数据)比当前数据要大，那么就进入循环比较[参考第二趟排序]
  int j = i - 1;

  while (j >= 0 && arrays[j] > temp) {

    //往后退一个位置，让当前数据与之前前位进行比较
    arrays[j + 1] = arrays[j];

    //不断往前，直到退出循环
    j--;

  }
  //退出了循环说明找到了合适的位置了，将当前数据插入合适的位置中
  arrays[j + 1] = temp;

}
System.out.println(  arrays);

```

##快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以**递归**进行，以此达到整个数据变成有序序列。

